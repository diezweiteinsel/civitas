stages:
  - build
  - test
  - deploy

default:
  interruptible: true

variables:
  # Variables for the test stage
  POSTGRES_DB_TEST: civitas_db_test
  POSTGRES_USER_TEST: civitas_user
  POSTGRES_PASSWORD_TEST: securepassword
  DATABASE_URL_TEST: "postgresql://${POSTGRES_USER_TEST}:${POSTGRES_PASSWORD_TEST}@db:5432/${POSTGRES_DB_TEST}"

### BUILD STAGE ###
# This stage builds the final Docker images and pushes them to the GitLab Registry.

build-backend:
  stage: build
  image: docker:24.0
  services:
    - docker:24.0-dind
  before_script:
    - echo "$CI_JOB_TOKEN" | docker login -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY
  script:
    # Build and push the backend image
    - docker build -t $CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA ./backend
    - docker push $CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA

build-frontend:
  stage: build
  image: docker:24.0
  services:
    - docker:24.0-dind
  before_script:
    - echo "$CI_JOB_TOKEN" | docker login -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY
  script:
    # Build and push the frontend image, using the public URL for production
    - docker build --build-arg REACT_APP_API_URL="http://134.245.1.240:1200" -f frontend/Dockerfile -t $CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA .
    - docker push $CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA

### TEST STAGE ###

test-backend:
  stage: test
  image: python:3.11-slim
  services:
    - name: postgres:15
      alias: db
  variables:
    # Override global DB variables for the test-specific service
    POSTGRES_DB: $POSTGRES_DB_TEST
    POSTGRES_USER: $POSTGRES_USER_TEST
    POSTGRES_PASSWORD: $POSTGRES_PASSWORD_TEST
    DATABASE_URL: $DATABASE_URL_TEST
    DB_HOST: db
    SECRET_KEY: "a-test-secret-key"
    ALGORITHM: "HS256"
  before_script:
    - apt-get update && apt-get install -y gcc libpq-dev
    - pip install -r backend/requirements-linux.txt
  script:
    - pytest backend/ --junitxml=report.xml
  artifacts:
    when: always
    reports:
      junit: report.xml

### DEPLOY STAGE ###

deploy-to-vm:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client docker-compose
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh && chmod 700 ~/.ssh
    - '[[ -f /.dockerenv ]] && echo -e "Host *\n\tStrictHostKeyChecking no\n\n" > ~/.ssh/config'
  script:
    - scp ./docker-compose.prod.yml $SSH_USER@$SSH_SERVER_IP:${VM_DEPLOY_PATH}/docker-compose.prod.yml
    - |
      ssh $SSH_USER@$SSH_SERVER_IP "
        echo '--- Starting Deployment on VM ---'
        
        # 1. Ensure directories exist and navigate to deploy path
        mkdir -p ${VM_DEPLOY_PATH} ~/docker_config
        cd ${VM_DEPLOY_PATH}
        
        # 2. Set DOCKER_CONFIG to use our custom path
        export DOCKER_CONFIG=~/docker_config
        
        # 3. Log in to the GitLab Container Registry using a Deploy Token
        docker login -u ${CI_DEPLOY_USER} -p ${CI_DEPLOY_PASSWORD} ${CI_REGISTRY}

        # 4. Export variables for docker-compose to use
        export CI_REGISTRY_IMAGE=${CI_REGISTRY_IMAGE}
        export CI_COMMIT_SHA=${CI_COMMIT_SHA}
        export POSTGRES_DB=${POSTGRES_DB}
        export POSTGRES_USER=${POSTGRES_USER}
        export POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
        export SECRET_KEY=${SECRET_KEY}
        export ALGORITHM=${ALGORITHM}
        
        # 5. Pull the latest images
        echo 'Pulling new images...'
        docker-compose -f docker-compose.prod.yml pull
        
        # 6. Stop the old containers and start the new ones
        echo 'Restarting services...'
        docker-compose -f docker-compose.prod.yml up -d --remove-orphans
        
        echo '--- Deployment Successful ---'
      "
  environment:
    name: production
    url: http://${SSH_SERVER_IP}:1200
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
