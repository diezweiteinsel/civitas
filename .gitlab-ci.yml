stages:
  - build
  - test
  - deploy

default:
  interruptible: true

variables:
  POSTGRES_DB_TEST: civitas_db_test
  POSTGRES_USER_TEST: civitas_user
  POSTGRES_PASSWORD_TEST: securepassword
  DATABASE_URL_TEST: "postgresql://${POSTGRES_USER_TEST}:${POSTGRES_PASSWORD_TEST}@db:5432/${POSTGRES_DB_TEST}"

# ---- BUILD (sanity builds only; no registry) ----
build-backend:
  stage: build
  image: docker:24.0
  services: ["docker:24.0-dind"]
  script:
    - docker build -t sanity-backend:ci ./backend

build-frontend:
  stage: build
  image: docker:24.0
  services: ["docker:24.0-dind"]
  script:
    - docker build --build-arg REACT_APP_API_URL="/api" -f frontend/Dockerfile -t sanity-frontend:ci .

# ---- TEST ----
test-backend:
  stage: test
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - .cache/pip
  variables:
    PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"
  image: python:3.11-slim
  services:
    - name: postgres:15
      alias: db
  variables:
    POSTGRES_DB: $POSTGRES_DB_TEST
    POSTGRES_USER: $POSTGRES_USER_TEST
    POSTGRES_PASSWORD: $POSTGRES_PASSWORD_TEST
    # for testing the pipeline, we hardcode the test DB URL here
    DATABASE_URL: "postgresql://civitas_user:securepassword@db:5432/civitas_db_test"
    DB_HOST: db
    SECRET_KEY: "a-test-secret-key"
    ALGORITHM: "HS256"
    DEV_SQLITE: "0"
  before_script:
    # keep the image lean → avoid filling /var/cache/apt/archives
    - rm -rf /var/lib/apt/lists/* /var/cache/apt/archives/*
    - apt-get update
    - apt-get install -y --no-install-recommends gcc libpq-dev
    - apt-get clean
    - rm -rf /var/lib/apt/lists/* /var/cache/apt/archives/*
    - pip install -r backend/requirements-linux.txt
    - pip install -e backend/.
    - pip install pytest-cov
  script:
  - pytest backend/ --junitxml=report.xml --cov=backend --cov-report=xml:coverage.xml --cov-report=html:htmlcov --cov-report=term-missing
  - 'test -f report.xml || echo "<testsuite name=\"pytest\" tests=\"0\" failures=\"1\"><testcase classname=\"collection\" name=\"error\"><failure message=\"pytest crashed before producing report.xml\"/></testcase></testsuite>" > report.xml'

  artifacts:
    when: always
    paths:
      - report.xml
      - coverage.xml
      - htmlcov/
    expire_in: 1 week
    reports:
      junit: report.xml
      cobertura: coverage.xml

# ---- DEPLOY (scp repo → build/run on VM) ----
deploy-to-vm:
  stage: deploy
  image: alpine:latest
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  before_script:
    - apk add --no-cache git openssh-client tar gzip docker-cli-compose
    - eval $(ssh-agent -s)

    # --- validate and normalize the File variable to a real key file ---
    - test -f "$SSH_PRIVATE_KEY" || { echo "SSH_PRIVATE_KEY must be a File variable"; exit 1; }
    # strip CRLF safely into a new file
    - tr -d '\r' < "$SSH_PRIVATE_KEY" > id_deploy
    - chmod 600 id_deploy
    # sanity: must look like an OpenSSH private key and be usable (no passphrase)
    - grep -q "^-----BEGIN OPENSSH PRIVATE KEY-----" id_deploy || { echo "Not an OpenSSH private key"; exit 1; }
    - ssh-keygen -y -f id_deploy >/dev/null || { echo "Invalid or passphrase-protected key"; exit 1; }

    - ssh-add id_deploy

    - mkdir -p ~/.ssh && chmod 700 ~/.ssh
    - printf "Host *\n\tStrictHostKeyChecking no\n\tPort %s\n" "$SSH_PORT" > ~/.ssh/config

  script:
    - git config --global --add safe.directory "$CI_PROJECT_DIR"
    - git archive --format=tar HEAD | gzip > app.tar.gz

    # build backend.env LOCALLY (CI expands vars here) — no heredoc
    - printf '%s\n' \
      'DB_HOST=db' 'DB_PORT=5432' \
      "DB_NAME=$POSTGRES_DB" "DB_USERNAME=$POSTGRES_USER" "DB_PASSWORD=$POSTGRES_PASSWORD" \
      "POSTGRES_DB=$POSTGRES_DB" "POSTGRES_USER=$POSTGRES_USER" "POSTGRES_PASSWORD=$POSTGRES_PASSWORD" \
      "SECRET_KEY=$SECRET_KEY" "ALGORITHM=$ALGORITHM" \
      'DEV_SQLITE=0' 'SKIP_CREATE_ALL=0' 'ECHO_SQL=0' \
      "ALLOWED_ORIGINS=$ALLOWED_ORIGINS" 'PYTHONPATH=/app' > backend.env 

      # derive pubkey + show fingerprint (no secret)
    - ssh-keygen -y -f id_deploy > id_deploy.pub
    - ssh-keygen -lf id_deploy.pub
    - ssh-keygen -y -f id_deploy > id_deploy.pub
    - cat id_deploy.pub
    # strict auth so it doesn’t try password
    - ssh -o BatchMode=yes -o PreferredAuthentications=publickey -p "$SSH_PORT" "$SSH_USER@$SSH_SERVER_IP" "echo OK" || true
    - ssh -p "$SSH_PORT" "$SSH_USER@$SSH_SERVER_IP" "echo PATH=\$PATH; which tar; which mkdir; which docker"

    - ssh -p "$SSH_PORT" "$SSH_USER@$SSH_SERVER_IP" "mkdir -p '$VM_DEPLOY_PATH'"
    - ssh -o BatchMode=yes -P "$SSH_PORT" "$SSH_USER@$SSH_SERVER_IP" "echo OK-SSH && whoami && hostname"
    - scp -P "$SSH_PORT" app.tar.gz "$SSH_USER@$SSH_SERVER_IP:$VM_DEPLOY_PATH/app.tar.gz"
    - scp -P "$SSH_PORT" backend.env "$SSH_USER@$SSH_SERVER_IP:$VM_DEPLOY_PATH/backend.env"

    # unpack, move .env, build & run — single SSH command, no multiline
    - |
      ssh -p "$SSH_PORT" "$SSH_USER@$SSH_SERVER_IP" "
        set -e
        cd '$VM_DEPLOY_PATH'
        export DOCKER_CONFIG=$VM_DEPLOY_PATH/.docker
        mkdir -p \$DOCKER_CONFIG
        tar -xzf app.tar.gz && rm -f app.tar.gz
        mkdir -p backend && install -m 600 backend.env backend/.env && rm -f backend.env
        docker compose -f docker-compose.prod.yml build --pull
        docker compose -f docker-compose.prod.yml up -d --remove-orphans
        docker compose ps
      "




  environment:
    name: production
    url: http://$SSH_SERVER_IP:1203

